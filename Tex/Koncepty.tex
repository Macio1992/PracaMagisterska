\documentclass[11pt, a4paper]{article}
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage{listings}

\begin{document}
\lstset{language=C++}

\section{Koncepty}

W 1987 próbowano projektować szablony z odpowiednimi interfejsami. Chciano by szablony:

\begin{itemize}

\item były w pełni ogólne i wyraziste
\item by nie wykorzystywały większych zasobów w porównaniu do kodowania ręcznego
\item by miały dobrze określone interfejsy

\end{itemize}

\noindent Długo nie dało się osiągnąć tych trzech rzeczy, ale za to osiągnięto:

\begin{itemize}

\item \emph{kompletność Turinga}\footnote{(ang. Turing Completness) umiejętność do rozwiązania każdej odpowiedzi. Program, który jest kompletny według Turinga może być wykorzystany do symulacji jakiejkolwiek 1-taśmowej maszyny Turinga}
\item lepszą wydajność (w porównaniu do kodu pisanego ręcznie)
\item kiepskie interfejsy (praktycznie \emph{typowanie kaczkowe czasu kompilacji})\footnote{(ang. duck typing) rozpoznanie typu obiektu, nie na podstawie deklaracji, ale przez badanie metod udostępnionych przez obiekt}

\end{itemize}

Brak dobrze określonych interfejsów prowadzi do spektakularnie złych wiadomości błędów. Dwie pozostałe właściwości uczyniły z szablonów sukces.

Rozwiązanie problemu specyfikacji interfejsu zostało, przez Alexa Stepanova nazwane \textbf{konceptami}. \textbf{Koncept} to zbiór wymagań argumentów szablonu. Można też go nazwać systemem typów dla szablonów, który obiecuje znacząco ulepszyć diagnostyki błędów i zwiększyć siłę ekspresji, taką jak przeciążanie oparte na konceptach oraz częściowa specjalizacja szablonu funkcji.

Koncepty (\emph{The Concepts TS}\footnote{(ang. The Concepts Technical Specification) Specyfikacja techniczna konceptów}) zostały opublikowane i zaimplementowane w wersji 6.1 kompilatora GCC w kwietniu 2016 roku. Fundamentalnie to predykaty czasu kompilacji typów i wartości. Mogą być łączone zwykłymi operatorami logicznymi (\verb#&&#, \verb#||#, \verb#!#)

\subsection{Podstawy konceptów}

Reprezentacja definicji szablonu w C++ to zazwyczaj drzewa wyprowadzania\footnote{(ang. Parse Trees)}. Używając identycznych technik kompilatora, możemy przekonwertować koncepty do drzew wyprowadzania. Posiadając to możemy zaimplementować sprawdzanie konceptów jako abstrakcyjne drzewo dopasowań\footnote{(ang. Abstract Tree Matching)}. Wygodnym sposobem implementowania takiego dopasowywania jest generowanie i porównywanie zestawów wymaganych funkcji i typów (zwane \emph{zestawami ograniczeń}) z definicji szablonów i konceptów.

Definicja konceptu to zestaw równań \emph{drzewa AST}\footnote{(ang. Abstract Syntax Tree)} z założeniami typu. Koncepty dają dwa zamysły:

\begin{enumerate}

\item w \emph{definicjach szablonu}, koncepty działają jak reguły osądzania typowania. Jeśli \emph{drzewo AST} zależy od parametrów szablonu i nie może być rozwiązane przez otaczające środowisko typowania, wtedy musi się pojawić w strzegących ciałach konceptów. Takie zależne \emph{drzewa AST} są domniemanymi parametrami konceptów i zostaną rozwiązane przez sprawdzanie konceptów w momentach użycia.

\item w \emph{użyciach szablonów}, koncepty działają jak zestawy predykatów, które argumenty szablonu muszą spełniać. Sprawdzanie konceptów rozwiązuje domniemane parametry w momentach inicjalizacji.

\end{enumerate}

\subsection{Ulepszenie programowania generycznego}
\verb#double pierwiastek(double d);# \newline
\verb#double d = 7;# \newline
\verb#double d2 = pierwiastek(d);# \newline
\verb#vector<string> v = {"jeden", "dwa"};# \newline
\verb#double d3 = pierwiastek(v);# \newline

Mamy funkcję \verb#pierwiastek#, która jako parametr przyjmuje zmienną typu \verb#double#. Jeśli dostarczymy taki typ, wszystko będzie w porządku, ale jeśli damy inny typ od razu otrzymamy pomocną wiadomość błędu.

\begin{lstlisting}[frame=single]
template<class T>
void sortuj(T &c){
   //kod sortowania
}
\end{lstlisting}

Kod funkcji \verb#sortuj# zależy od różnych właściwości typu \verb#T#, takiej jak posiadanie operatora [] \newline

\noindent \verb#vector<string> v = {"jeden", "dwa"};# \newline
\verb#sortuj(v);# \newline
\verb#//OK: zmienna v ma wszystkie syntaktyczne właściwości# \newline
\verb#wymagane przez funkcję sort# \newline\newline
\verb#double d = 7;# \newline
\verb#sortuj(d);# \newline
\verb#//Błąd: zmienna d nie ma operatora []#\newline

\noindent Mamy kilka problemów:\newline
\begin{itemize}

\item wiadomośc błędu jest niejednoznaczna i daleko jej do precyzyjnej i pomocnej, tak jak : "Błąd: zmienna d nie ma operatora []"

\item aby użyć funkcji \verb#sortuj#, musimy dostarczyć jej definicję, a nie tylko deklaracje. Jest to różnica w sposobie pisania zwykłego kodu i zmienia się model organizowania kodu

\item wymagania funkcji dotyczące typu argumentu są domniemane w ciałach ich funkcji

\item wiadomość błędu funkcji pojawi się tylko podczas inicjalizacji szablonu, a to może się zdarzyć bardzo długo po momencie wywołania

\item Notacja \verb#template<typename T># jest powtarzalna, bardzo nielubiana.

\end{itemize}

Używając konceptu, możemy dotrzeć do źródła problemu, poprzez poprawne określanie wymagań argumentów szablonu. Fragment kodu używającego konceptu \verb#Sortable#:\newline

\noindent \verb#void sortuj(Sortable &c);//(1)#\newline
\verb#vector<string> v = {"jeden", "dwa"};#\newline
\verb#sortuj(v);//(2)# \newline
\verb#double d = 7;# \newline
\verb#sortuj(d);//(3)# \newline

\noindent (1) - akceptuj jakąkolwiek zmienną c, która jest \verb#Sortable# \newline
(2) - OK: \verb#v# jest kontenerem typu \verb#Sortable# \newline
(3) - Błąd: d nie jest \verb#Sortable# (\verb#double# nie dostarcza operatora [], itd. \newline

Kod jest analogiczny do przykładu \verb#pierwiastek#. Jedyna różnica polega na tym, że:
\begin{itemize}

\item w przypadku typu \verb#double#, projektant języka wbudował go do kompilatora jak określony typ, gdzie jego znaczenie zostało określone w dokumentacji

\item zaś w przypadku \verb#Sortable#, użytkownik określił co on oznacza w kodzie. Typ jest \verb#Sortable# jeśli posiada właściwości \verb#begin()# i \verb#end()# dostarczające losowy dostęp do sekwencji zawierającej elementy, które mogą być porównywane używając operatora \verb#<#

\end{itemize}

Teraz otrzymujemy bardziej jasny komunikat błędu. Jest on generowany natychmiast w momencie gdzie kompilator widzi błędne wywołanie (\verb#sortuj(d);#)

Cele to zrobienie:
\begin{itemize}

\item kodu generycznego tak prostym jak nie-generyczny

\item bardziej zaawansowanego kodu generycznego tak łatwym do użycia i nie tak trudnym do
pisania

\end{itemize}

\subsection{Używanie konceptów}

Koncept to predykat czasu kompilacji (coś co zwraca wartość boolowską). Np. argument typu szablonu \verb#T# mógłby mieć wymagania żeby być:

\begin{itemize}

\item iteratorem \verb#Iterator<T>#

\item iteratorem losowego dostępu \verb#Random_access_iterator<T>#

\item liczbą: \verb#Number<T>#

\end{itemize}

Notacja \verb#C<T>#, gdzie \verb#C# to koncept a \verb#T# to typ, to wyrażenie znaczące "prawda jeśli \verb#T# spełnia wszystkie wymagania C, a nieprawda w przeciwnym wypadku."

Podobnie, możemy określić, że zestaw argumentów szablonu musi spełniać predykat, np. \verb#Mergeable<In1, In2, Out>#. Taki predykaty wielu typów są niezbędne do opisywania biblioteki STL i wielu innych. Są bardzo ekspresywne i łatwo kompilowalne (tańsze niż obejścia metaprogramowania szablonów). Można oczywiście definiować własne koncepty i można tworzyć biblioteki konceptów. Koncepty pozwalają na przeciążanie i eliminują potrzebę wielokrotnego doraźnego metaprogramowania i kodu \emph{scaffoldingu}\footnote{metaprogramistyczna metoda budowania aplikacji bazodanowych. To technika wspierana przez niektóre frameworki MVC, w których programista może napisać specyfikację opisującą sposób wykorzystania bazy danych aplikacji. Kompilator używa tej specyfikacji, aby wygenerować kod, który aplikacja może wykorzystać do odczytu, tworzenia, aktualizacji i usuwania wpisów bazy danych } z metaprogramowania, co znacznie upraszcza metaprogramowanie, a także programowanie generyczne.

\subsection{Określanie interfejsu szablonu}

\begin{lstlisting}[frame=single]
template<typename S, typename T>
   requires Sequence<S> && 
   Equality_comparable<Value_type<S>, T>
Iterator_of<S> szukaj(S &seq, const T &value);
\end{lstlisting}

Powyższy szablon przyjmuje dwa argumenty typu szablonu. Pierwszy argument typu musi być typu \verb#Sequence# i musimy być w stanie porównywać elementy sekwencji ze zmienną \verb#value# używając operatora \verb#==# (stąd \verb#Equality_comparable<Value_type<S>, T>#). Funkcja \verb#szukaj# przyjmuje sekwencję przez referencję i \verb#value# do znalezienia jako referencję \verb#const#. Zwraca iterator.

Sekwencja musi posiadać \verb#begin()# i \verb#end()#. Koncept \verb#Equality_comparable# jest zaproponowany jako koncept standardowej biblioteki. Wymaga by jego argument dostarczał operatory \verb#==# i \verb#!=#. Ten koncept przyjmuje dwa argumenty. Wiele konceptów przyjmuje więcej niż jeden argument. Koncepty mogą opisywać nie tylko typy, ale również związki między typami. \newline

Użycie funkcji \verb#szukaj#: \newline

\begin{lstlisting}[frame=single]
void test(vector<string> &v, list<double> &list){
   auto a0 = szukaj(v, "test");(1)
   auto p1 = szukaj(v, 0.7);(2)
   auto p2 = szukaj(list, 0.7);(3)
   auto p3 = szukaj(list, "test");(4)
   
   if(a0 != v.end()){
     //Znaleziono "test"
   }
}
\end{lstlisting}

1) OK
2) Błąd: nie można porównać string do double
3) OK
4) Błąd: nie można porównać double ze string

\subsection{Notacja skrótowa}
Gdy chcemy podkreślić, że argument szablonu ma być sekwencją, piszemy:

\begin{lstlisting}[frame=single]
template<typename Seq>
   requires Sequence<Seq>
void algo(Seq &s);

\end{lstlisting}

To oznacza, że potrzebujemy argumentu typu \verb#Seq#, który musi być typu \verb#Sequence#, lub innymi słowy: Szablon przyjmuje argument typu, który musi być typu \verb#Sequence#. Możemy to uprościć:

\begin{lstlisting}[frame=single]
template<Sequence Seq>
void algo(Seq &s);

\end{lstlisting}

To znaczy dokładnie to samo co dłuższa wersja, ale jest krótsza i lepiej wygląda. Używamy tej notacji dla konceptów z jednym argumentem. Np. moglibyśmy uprościć funkcję \verb#szukaj#: \newline

\begin{lstlisting}[frame=single]
template<Sequence S, typename T>
   requires Equality_comparable<Value_type<S>, T>
Iterator_of<S> szukaj(S &seq, const T &value);
\end{lstlisting}

Upraszcza to składnię języka. Sprawia, że nie jest zbyt zagmatwana.

\subsection{Definiowanie konceptów}

Koncepty, takie jak \verb#Equality_comparable# często można znaleźć w bibliotekach (np. w \verb#The Ranges TS#), ale koncepty można też definiować samodzielnie: \newline

\begin{lstlisting}[frame=single]
template<typename T>
concept bool Equality_comparable = requires (T a, T b){
   { a == b } -> bool; //(1)
   { a != b } -> bool; //(2)
};

\end{lstlisting}

Koncept ten został zdefiniowany jako szablonowa zmienna. Typ musi dostarczać operacje \verb#==# i \verb#!=#, z których każda musi zwracać wartość \verb#bool#, żeby być \verb#Equality_comparable#
. Wyrażenie \verb#requires# pozwala na bezpośrednie wyrażenie jak typ może być użyty:

\begin{itemize}

\item \verb#{ a == b }#, oznajmia, że dwie zmienne typu \verb#T# powinny być porównywalne używając operatora \verb#==#

\item \verb#{ a == b} -> bool# mówi że wynik takiego porównania musi być typu \verb#bool#

\end{itemize}

Wyrażenie \verb#requires# jest właściwie nigdy nie wykonywane. Zamiast tego kompilator patrzy na wymagania  i zwraca \verb#true# jeśli się skompilują a \verb#false# jeśli nie. To bardzo potężne ułatwienie. 

\begin{lstlisting}[frame=single]
template<typename T>
concept bool Sequence = requires(T t) {
   typename Value_type<T>;
   typename Iterator_of<T>;
   
   { begin(t) } -> Iterator_of<T>;
   { end(t) } -> Iterator_of<T>;
   
   requires Input_iterator<Iterator_of<T>>;
   requires Same_type<Value_type<T>,
   Value_type<Iterator_of<T>>>;
};

\end{lstlisting}

Żeby być typu \verb#Sequence#:

\begin{itemize}

\item typ \verb#T# musi mieć dwa powiązane typy: \verb#Value_type<T># i \verb#Iterator_of<T>#. Oba typy to zwykłe \emph{aliasy szablonu}\footnote{ALIAS SZABLONU}. Podanie tych typów w wyrażeniu \verb#requires# oznacza, że typ \verb#T# musi je posiadać żeby być \verb#Sequence#.

\item typ \verb#T# musi mieć operacje \verb#begin()# i \verb#end()#, które zwracają odpowiednie iteratory.

\item odpowiedni iterator oznacza to, że typ iteratora typu \verb#T# musi być typu \verb#Input_iterator# i typ wartości typu \verb#T# musi być taka sama jak jej wartość typu jej iteratora. \verb#Input_iterator# i \verb#Same_type# to koncepty z biblioteki.

\end{itemize}

Teraz w końcu możemy napisać koncept \verb#Sortable#. Żeby typ był \verb#Sortable#, powinien być sekwencją oferującą losowy dostęp i posiadać typ wartości, który wspiera porównania używające operatora \verb#<#:

\begin{lstlisting}[frame=single]
template<typename T>
concept bool Sortable = Sequence<T> &&
Random_access_iterator<Iterator_of<T>> &&
Less_than_comparable<Value_type<T>>;
\end{lstlisting}

\verb#Random_access_iterator# i \verb#Less_than_comparable# są zdefiniowane analogicznie do \verb#Equality_comparable#

Często, wymagane są relacje pomiędzy konceptami. Np. koncept \verb#Equality_comparable# jest zdefiniwoany by wymagał jeden typ. Można zdefiniować ten koncept by radził sobie z dwoma typami:

\begin{lstlisting}[frame=single]
template<typename T, typename U>
concept bool Equality_comparable = requires (T a, U b) {
   { a == b } -> bool;
   { a != b } -> bool;
   { b == a } -> bool;
   { b != a } -> bool;
};
\end{lstlisting}

To pozwala na porównywanie zmiennych typu \verb#int# z \verb#double# i \verb#string# z \verb#char*#, ale nie \verb#int# z \verb#string#.

\end{document}